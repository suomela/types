#include <assert.h>
#include <errno.h>
#include <math.h>
#include <stdlib.h>
#include <string.h>
#include "config.h"
#include "input.h"
#include "malloc.h"
#include "version.h"

const word_token_t WORD_TOKEN_NULL_C = WORD_TOKEN_NULL;

const input_t INPUT_NULL_C = {
    MYFILE_NULL, MYFILE_NULL, MYFILE_NULL,
    YXBOOL_NULL, YXBOOL_NULL,
    0, 0, 0, 0, 0,
    false, false, false,
    MATRIX_NULL, MATRIX_NULL, ARRAY_NULL,
    NULL,
    X_NULL, Y_NULL
};

static void
usage(void)
{
    short_version();
    printf(
        "\n"
        "Computation.\n"
        "\n"
        "This is a low-level tool. See 'types-run' for a user-friendly interface.\n"
        "\n"
        "usage: %s [OPTION]...\n"
        "\n"
        "For curves and permutation testing:\n"
        "  --iterations ITERATIONS  Number of iterations.\n"
        "  --raw-input FILE         Read all input from FILE.\n"
        "  --raw-output FILE        Write all input to FILE.\n"
        "  --rng-state-file FILE    File generated by types-rng.\n"
        "\n"
        "For curves:\n"
        "  --x SLOTS                Maximum x resolution (number of slots).\n"
        "  --y SLOTS                Maximum y resolution (number of slots).\n"
        "  --type-word              Calculate type/word curves.\n"
        "  --type-token             Calculate type/token curves.\n"
        "  --hapax-word             Calculate hapax/word curves.\n"
        "  --hapax-token            Calculate hapax/token curves.\n"
        "  --token-word             Calculate token/word curves.\n"
        "\n"
        "For permutation testing:\n"
        "  --p-type-word            Calculate type/word statistics.\n"
        "  --p-type-token           Calculate type/token statistics.\n"
        "  --p-hapax-word           Calculate hapax/word statistics.\n"
        "  --p-hapax-token          Calculate hapax/token statistics.\n"
        "  --p-token-word           Calculate token/word statistics.\n"
        "\n"
        "Other options:\n"
        "  --processes N            Total number of parallel processes.\n"
        "  --id ID                  Identifier of this process (1..N).\n"
        "  --progress               Print progress information to stderr.\n"
        "  --sparse                 Optimise for sparse inputs.\n"
        "  --dense                  Optimise for dense inputs.\n"
        "  --help                   This help.\n"
        "  --version                Version and copyright information.\n"
        "\n"
        "In all file names, \"-\" can be used to denote stdin/stdout.\n"
        "\n",
        TOOL);
}

static unsigned
get_uint(const char * restrict context, const char * restrict s)
{
    if (*s == '\0') {
        myerror("%s: expected an integer, got an empty string: %s", context, s);
    }
    char *pend;
    errno = 0;
    long long v = strtoll(s, &pend, 10);
    if (*pend != '\0') {
        myerror("%s: not a valid integer: %s", context, s);
    }
    if (errno == ERANGE) {
        myerror("%s: integer overflow: %s", context, s);
    }
    if (v > UINT_MAX) {
        myerror("%s: value too large: %s", context, s);
    }
    if (v < 0) {
        myerror("%s: value has to be nonnegative: %s", context, s);
    }
    return (unsigned)v;
}

static bool
pcl_uint(int argc,
         char **argv,
         int * restrict pi,
         const char * restrict option,
         unsigned * restrict target,
         unsigned minimum)
{
    assert(minimum > 0);
    assert(*pi < argc);
    if (strcmp(argv[*pi], option) == 0) {
        (*pi)++;
        if (*target > 0) {
            myerror("%s specified twice", option);
        }
        if (*pi == argc) {
            myerror("%s expects an argument", option);
        }
        *target = get_uint(option, argv[*pi]);
        (*pi)++;
        if (*target < minimum) {
            myerror("%s: the argument must be at least %u", option, minimum);
        }
        return true;
    } else {
        return false;
    }
}

static bool
pcl_file(int argc,
         char **argv,
         int * restrict pi,
         const char * restrict option,
         myfile_t * restrict target,
         bool write)
{
    assert(*pi < argc);
    if (strcmp(argv[*pi], option) == 0) {
        (*pi)++;
        if (is_open(target)) {
            myerror("%s specified twice", option);
        }
        if (*pi == argc) {
            myerror("%s expects an argument", option);
        }
        const char *filename = argv[*pi];
        (*pi)++;
        if (strcmp(filename, "-") == 0) {
            *target = write ? myopen_stdout() : myopen_stdin();
        } else {
            *target = myopen(filename, write);
        }
        return true;
    } else {
        return false;
    }
}

static bool
pcl_bool(int argc,
         char **argv,
         int * restrict pi,
         const char * restrict option,
         bool * restrict target)
{
    assert(*pi < argc);
    if (strcmp(argv[*pi], option) == 0) {
        (*pi)++;
        if (*target) {
            myerror("%s specified twice", option);
        }
        *target = true;
        return true;
    } else {
        return false;
    }
}

void
parse_command_line(input_t * restrict pinput, int argc, char **argv)
{
    if (argc == 1) {
        usage();
        exit(EXIT_SUCCESS);
    }

    int i = 1;
    while (i < argc) {
        if (strcmp(argv[i], "--help") == 0 || strcmp(argv[i], "-h") == 0) {
            usage();
            exit(EXIT_SUCCESS);
        } else if (strcmp(argv[i], "--version") == 0 ||
                   strcmp(argv[i], "-v") == 0 ||
                   strcmp(argv[i], "-V") == 0) {
            version();
            exit(EXIT_SUCCESS);
        } else if (pcl_uint(argc, argv, &i, "--iterations",    &pinput->iterations, 1)) {
        } else if (pcl_uint(argc, argv, &i, "--x",             &pinput->xres, 2)) {
        } else if (pcl_uint(argc, argv, &i, "--y",             &pinput->yres, 2)) {
        } else if (pcl_uint(argc, argv, &i, "--processes",     &pinput->processes, 1)) {
        } else if (pcl_uint(argc, argv, &i, "--id",            &pinput->id, 1)) {
        } else if (pcl_file(argc, argv, &i, "--rng-state-file",&pinput->rng_state_file, false)) {
        } else if (pcl_file(argc, argv, &i, "--raw-input",     &pinput->raw_input_file, false)) {
        } else if (pcl_file(argc, argv, &i, "--raw-output",    &pinput->raw_output_file, true)) {
        } else if (pcl_bool(argc, argv, &i, "--progress",      &pinput->progress)) {
        } else if (pcl_bool(argc, argv, &i, "--sparse",        &pinput->sparse)) {
        } else if (pcl_bool(argc, argv, &i, "--dense",         &pinput->dense)) {
        } else {
            bool done = false;
            for (unsigned j = 0; j < NYX; j++) {
                if (pcl_bool(argc, argv, &i, YX[j].cswitch, &pinput->curves.yx[j])) {
                    done = true;
                    break;
                }
                if (pcl_bool(argc, argv, &i, YX[j].pswitch, &pinput->permtest.yx[j])) {
                    done = true;
                    break;
                }
            }
            if (!done) {
                myerror("unrecognised command line argument: '%s'", argv[i]);
            }
        }
    }

    if (pinput->processes == 0 && pinput->id > 0) {
        myerror("--id required if --processes specified");
    }
    if (pinput->processes > 0 && pinput->id == 0) {
        myerror("--processes required if --id specified");
    }
    if (pinput->processes == 0 && pinput->id == 0) {
        pinput->processes = 1;
        pinput->id = 1;
    } else if (pinput->id > pinput->processes) {
        myerror("--id is larger than --processes");
    }

    if (pinput->iterations == 0) {
        myerror("--iterations required");
    }
    if (!is_open(&pinput->rng_state_file)) {
        myerror("--rng-state-file required");
    }
    if (!is_open(&pinput->raw_input_file)) {
        myerror("--raw-input required");
    }
    if (!is_open(&pinput->raw_output_file)) {
        myerror("--raw-output required");
    }
    if (pinput->sparse && pinput->dense) {
        myerror("cannot specify both --sparse and --dense");
    }
}

void
free_input(const input_t * restrict pinput)
{
    free_matrix(&pinput->types);
    free_matrix(&pinput->collections);
    free_array(&pinput->word_count);
    if (pinput->samples_word_token) {
        free(pinput->samples_word_token);
    }
}
